<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhoudy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhoudyme.github.io/"/>
  <updated>2020-04-08T14:28:14.256Z</updated>
  <id>https://zhoudyme.github.io/</id>
  
  <author>
    <name>zhoudy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring5：@Autowired注解、@Resource注解和@Service注解[转载]</title>
    <link href="https://zhoudyme.github.io/2018/12/10/042b7d4679a411ea9e7f28d244de8d5a/"/>
    <id>https://zhoudyme.github.io/2018/12/10/042b7d4679a411ea9e7f28d244de8d5a/</id>
    <published>2018-12-10T12:10:02.000Z</published>
    <updated>2020-04-08T14:28:14.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h1><p>传统的Spring做法是使用.xml文件来对bean进行注入或者是配置aop、事物，这么做有两个缺点：</p><p>1、如果所有的内容都配置在.xml文件中，那么.xml文件将会十分庞大；如果按需求分开.xml文件，那么.xml文件又会非常多。总之这将导致配置文件的可读性与可维护性变得很低</p><p>2、在开发中在.java文件和.xml文件之间不断切换，是一件麻烦的事，同时这种思维上的不连贯也会降低开发的效率</p><p>为了解决这两个问题，Spring引入了注解，通过”@XXX”的方式，让注解与Java Bean紧密结合，既大大减少了配置文件的体积，又增加了Java Bean的可读性与内聚性。</p><p>本篇文章，讲讲最重要的三个Spring注解，也就是@Autowired、@Resource和@Service，希望能通过有限的篇幅说清楚这三个注解的用法。</p><h1 id="不使用注解"><a href="#不使用注解" class="headerlink" title="不使用注解"></a>不使用注解</h1><p>先看一个不使用注解的Spring示例，在这个示例的基础上，改成注解版本的，这样也能看出使用与不使用注解之间的区别，先定义一个老虎：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Tiger</span><br><span class="line">&#123;</span><br><span class="line">    private String tigerName = <span class="string">"TigerKing"</span>;</span><br><span class="line">    </span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"TigerName:"</span> + tigerName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个猴子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Monkey</span><br><span class="line">&#123;</span><br><span class="line">    private String monkeyName = <span class="string">"MonkeyKing"</span>;</span><br><span class="line">    </span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"MonkeyName:"</span> + monkeyName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个动物园：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Zoo</span><br><span class="line">&#123;</span><br><span class="line">    private Tiger tiger;</span><br><span class="line">    private Monkey monkey;</span><br><span class="line">    </span><br><span class="line">    public void setTiger(Tiger tiger)</span><br><span class="line">    &#123;</span><br><span class="line">        this.tiger = tiger;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setMonkey(Monkey monkey)</span><br><span class="line">    &#123;</span><br><span class="line">        this.monkey = monkey;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Tiger getTiger()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> tiger;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Monkey getMonkey()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> monkey;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> tiger + <span class="string">"\n"</span> + monkey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring的配置文件这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>   </span><br><span class="line">    xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line">    xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span>  </span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans </span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context/spring-context-4.2.xsd"</span></span><br><span class="line">    default-autowire=<span class="string">"byType"</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=<span class="string">"zoo"</span> class=<span class="string">"com.xrq.bean.Zoo"</span> &gt;</span><br><span class="line">        &lt;property name=<span class="string">"tiger"</span> ref=<span class="string">"tiger"</span> /&gt;</span><br><span class="line">        &lt;property name=<span class="string">"monkey"</span> ref=<span class="string">"monkey"</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=<span class="string">"tiger"</span> class=<span class="string">"com.xrq.domain.Tiger"</span> /&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"monkey"</span> class=<span class="string">"com.xrq.domain.Monkey"</span> /&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>都很熟悉，权当复习一遍了。</p><h1 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h1><p>@Autowired顾名思义，就是自动装配，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property。当然，getter看个人需求，如果私有属性需要对外提供的话，应当予以保留。</p><p>因此，引入@Autowired注解，先看一下spring配置文件怎么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>   </span><br><span class="line">    xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line">    xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span>  </span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans </span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context/spring-context-4.2.xsd"</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;context:component-scan base-package=<span class="string">"com.xrq"</span> /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=<span class="string">"zoo"</span> class=<span class="string">"com.xrq.bean.Zoo"</span> /&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"tiger"</span> class=<span class="string">"com.xrq.domain.Tiger"</span> /&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"monkey"</span> class=<span class="string">"com.xrq.domain.Monkey"</span> /&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>注意第10行，使用必须告诉spring一下我要使用注解了，告诉的方式有很多，&lt;context:component-scan base-package=”xxx” /&gt;是一种最简单的，spring会自动扫描xxx路径下的注解。</p><p>看到第12行，原来zoo里面应当注入两个属性tiger、monkey，现在不需要注入了。再看下，Zoo.java也很方便，把getter/setter都可以去掉：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Zoo</span><br><span class="line">&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Tiger tiger;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private Monkey monkey;</span><br><span class="line">    </span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> tiger + <span class="string">"\n"</span> + monkey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里@Autowired注解的意思就是，当Spring发现@Autowired注解时，将自动在代码上下文中找到和其匹配（默认是类型匹配）的Bean，并自动注入到相应的地方去。</p><p>有一个细节性的问题是，假如bean里面有两个property，Zoo.java里面又去掉了属性的getter/setter并使用@Autowired注解标注这两个属性那会怎么样？答案是<strong>Spring会按照xml优先的原则去Zoo.java中寻找这两个属性的getter/setter，导致的结果就是初始化bean报错。</strong></p><p>OK，假设此时我把.xml文件的13行、14行两行给去掉，再运行，会抛出异常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> org.springframework.beans.factory.BeanCreationException: Error creating bean with name <span class="string">'Zoo'</span>: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.xrq.domain.Tiger com.xrq.bean.Zoo.ttiger; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of <span class="built_in">type</span> [com.xrq.domain.Tiger] found <span class="keyword">for</span> dependency: expected at least 1 bean <span class="built_in">which</span> qualifies as autowire candidate <span class="keyword">for</span> this dependency. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=<span class="literal">true</span>)&#125;</span><br><span class="line">    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:334)</span><br><span class="line">    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1214)</span><br><span class="line">    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543)</span><br><span class="line">    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)</span><br><span class="line">    at org.springframework.beans.factory.support.AbstractBeanFactory<span class="variable">$1</span>.getObject(AbstractBeanFactory.java:305)</span><br><span class="line">    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)</span><br><span class="line">    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:301)</span><br><span class="line">    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:196)</span><br><span class="line">    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:772)</span><br><span class="line">    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:835)</span><br><span class="line">    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:537)</span><br><span class="line">    at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139)</span><br><span class="line">    at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:83)</span><br><span class="line">    at com.xrq.test.MyTest.main(MyTest.java:13)</span><br><span class="line">Caused by: org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.xrq.domain.Tiger com.xrq.bean.Zoo.ttiger; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of <span class="built_in">type</span> [com.xrq.domain.Tiger] found <span class="keyword">for</span> dependency: expected at least 1 bean <span class="built_in">which</span> qualifies as autowire candidate <span class="keyword">for</span> this dependency. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=<span class="literal">true</span>)&#125;</span><br><span class="line">    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor<span class="variable">$AutowiredFieldElement</span>.inject(AutowiredAnnotationBeanPostProcessor.java:571)</span><br><span class="line">    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)</span><br><span class="line">    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:331)</span><br><span class="line">    ... 13 more</span><br><span class="line">Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of <span class="built_in">type</span> [com.xrq.domain.Tiger] found <span class="keyword">for</span> dependency: expected at least 1 bean <span class="built_in">which</span> qualifies as autowire candidate <span class="keyword">for</span> this dependency. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=<span class="literal">true</span>)&#125;</span><br><span class="line">    at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoSuchBeanDefinitionException(DefaultListableBeanFactory.java:1373)</span><br><span class="line">    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1119)</span><br><span class="line">    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1014)</span><br><span class="line">    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor<span class="variable">$AutowiredFieldElement</span>.inject(AutowiredAnnotationBeanPostProcessor.java:543)</span><br><span class="line">    ... 15 more</span><br></pre></td></tr></table></figure><p>因为，@Autowired注解要去寻找的是一个Bean，Tiger和 Monkey的Bean定义都给去掉了，自然就不是一个Bean了，Spring容器找不到也很好理解。那么，如果属性找不到我不想让Spring容器抛 出异常，而就是显示null，可以吗？可以的，其实异常信息里面也给出了提示了，就是将@Autowired注解的required属性设置为false 即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Zoo</span><br><span class="line">&#123;</span><br><span class="line">    @Autowired(required = <span class="literal">false</span>)</span><br><span class="line">    private Tiger tiger;</span><br><span class="line">    </span><br><span class="line">    @Autowired(required = <span class="literal">false</span>)</span><br><span class="line">    private Monkey monkey;</span><br><span class="line">    </span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> tiger + <span class="string">"\n"</span> + monkey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Autowired接口注入"><a href="#Autowired接口注入" class="headerlink" title="@Autowired接口注入"></a>@Autowired接口注入</h1><p>上面的比较简单，我们只是简单注入一个Java类，那么如果有一个接口，有多个实现，Bean里引用的是接口名，又该怎么做呢？比如有一个Car接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Car</span><br><span class="line">&#123;</span><br><span class="line">    public String carName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个实现类BMW和Benz：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BMW implements Car</span><br><span class="line">&#123;</span><br><span class="line">    public String carName()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"BMW car"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class Benz implements Car</span><br><span class="line">&#123;</span><br><span class="line">    public String carName()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"Benz car"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个CarFactory，引用Car：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class CarFactory</span><br><span class="line">&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Car car;</span><br><span class="line">    </span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> car.carName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不用说，一定是报错的，Car接口有两个实现类，Spring并不知道应当引用哪个实现类。这种情况通常有两个解决办法：</p><p>1、删除其中一个实现类，Spring会自动去base-package下寻找Car接口的实现类，发现Car接口只有一个实现类，便会直接引用这个实现类</p><p>2、实现类就是有多个该怎么办？此时可以使用@Qualifier注解：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class CarFactory</span><br><span class="line">&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(<span class="string">"BMW"</span>)</span><br><span class="line">    private Car car;</span><br><span class="line">    </span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> car.carName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意@Qualifier注解<strong>括号里面的应当是Car接口实现类的类名，我之前试的时候一直以为是bean的名字，所以写了”bMW”，结果一直报错。</strong></p><h1 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h1><p>把@Resource注解放在@Autowired下面说，是因为它们作用非常相似，这个就简单说了，例子过后点明一下@Resource和@Autowired的区别。先看一下@Resource，直接写Zoo.java了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class Zoo</span><br><span class="line">&#123;</span><br><span class="line">    @Resource(name = <span class="string">"tiger"</span>)</span><br><span class="line">    private Tiger tiger;</span><br><span class="line">    </span><br><span class="line">    @Resource(<span class="built_in">type</span> = Monkey.class)</span><br><span class="line">    private Monkey monkey;</span><br><span class="line">    </span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> tiger + <span class="string">"\n"</span> + monkey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是详细一些的用法，说一下@Resource的装配顺序：</p><p>1、@Resource后面没有任何内容，默认通过name属性去匹配bean，找不到再按type去匹配</p><p>2、指定了name或者type则根据指定的类型去匹配bean</p><p>3、指定了name和type则根据指定的name和type去匹配bean，任何一个不匹配都将报错</p><p>然后，区分一下@Autowired和@Resource两个注解的区别：</p><p>1、@Autowired默认按照byType方式进行bean匹配，@Resource默认按照byName方式进行bean匹配</p><p>2、@Autowired是Spring的注解，@Resource是J2EE的注解，这个看一下导入注解的时候这两个注解的包名就一清二楚了</p><p>Spring属于第三方的，J2EE是Java自己的东西，因此，建议使用@Resource注解，以减少代码和Spring之间的耦合。</p><h1 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h1><p>上面这个例子，还可以继续简化，因为spring的配置文件里面还有12行~14行三个bean，下一步的简化是把这三个bean也给去掉，使得spring配置文件里面只有一个自动扫描的标签，增强Java代码的内聚性并进一步减少配置文件。</p><p>要继续简化，可以使用@Service。先看一下配置文件，当然是全部删除了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>   </span><br><span class="line">    xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line">    xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span>  </span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans </span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context/spring-context-4.2.xsd"</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;context:component-scan base-package=<span class="string">"com.xrq"</span> /&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>是不是感觉很爽？起码我觉得是的。OK，下面以Zoo.java为例，其余的Monkey.java和Tiger.java都一样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class Zoo</span><br><span class="line">&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Tiger ttiger;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private Monkey mmonkey;</span><br><span class="line">    </span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> ttiger + <span class="string">"\n"</span> + mmonkey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，Zoo.java在Spring容器中存在的形式就是”zoo”，即可以通过ApplicationContext的getBean(“zoo”)方法来得到Zoo.java。@Service注解，其实做了两件事情：</p><p>1、声明Zoo.java是一个bean，这点很重要，因为Zoo.java是一个bean，其他的类才可以使用@Autowired将Zoo作为一个成员变量自动注入</p><p>2、Zoo.java在bean中的id是”zoo”，即类名且首字母小写</p><p>如果，我不想用这种形式怎么办，就想让Zoo.java在Spring容器中的名字叫做”Zoo”，可以的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Scope(<span class="string">"prototype"</span>)</span><br><span class="line">public class Zoo</span><br><span class="line">&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Monkey monkey;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Tiger tiger;</span><br><span class="line">    </span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"MonkeyName:"</span> + monkey + <span class="string">"\nTigerName:"</span> + tiger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就可以通过ApplicationContext的getBean(“zoo”)方法来得到Zoo.java了。</p><p>这里我还多加了一个@Scope注解，应该 很好理解。因为Spring默认产生的bean是单例的，假如我不想使用单例怎么办，xml文件里面可以在bean里面配置scope属性。注解也是一 样，配置@Scope即可，默认是”singleton”即单例，”prototype”表示原型即每次都会new一个新的出来。</p><h1 id="补充细节"><a href="#补充细节" class="headerlink" title="补充细节"></a>补充细节</h1><p>最后再补充一个我发现的细节。假如animal包下有Tiger、domain包下也有Tiger，它们二者都加了@Service注解，那么在Zoo.java中即使明确表示我要引用的是domain包下的Tiger，程序运行的时候依然会报错。</p><p>细想，其实这很好理解，两个Tiger都使 用@Service注解标注，意味着两个Bean的名字都是”tiger”，那么我在Zoo.java中自动装配的是哪个Tiger呢？不明确，因 此，Spring容器会抛出BeanDefinitionStoreException异常，Caused by：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.context.annotation.ConflictingBeanDefinitionException: Annotation-specified bean name <span class="string">'monkey'</span> <span class="keyword">for</span> bean class [com.xrq.domain.Monkey] conflicts with existing, non-compatible bean definition of same name and class [com.xrq.animal.Monkey]</span><br></pre></td></tr></table></figure><p>转载于：<a href="https://www.cnblogs.com/szlbm/p/5512931.html#top" target="_blank" rel="noopener">https://www.cnblogs.com/szlbm/p/5512931.html#top</a><br>作者：IT·达人</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是注解&quot;&gt;&lt;a href=&quot;#什么是注解&quot; class=&quot;headerlink&quot; title=&quot;什么是注解&quot;&gt;&lt;/a&gt;什么是注解&lt;/h1&gt;&lt;p&gt;传统的Spring做法是使用.xml文件来对bean进行注入或者是配置aop、事物，这么做有两个缺点：&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhoudyme.github.io/categories/JAVA/"/>
    
    
      <category term="Spring" scheme="https://zhoudyme.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>纯css，div隐藏滚动条，保留鼠标滚动效果[转载]</title>
    <link href="https://zhoudyme.github.io/2018/11/19/ba55bd2879a211ea9e7f28d244de8d5a/"/>
    <id>https://zhoudyme.github.io/2018/11/19/ba55bd2879a211ea9e7f28d244de8d5a/</id>
    <published>2018-11-19T11:10:51.000Z</published>
    <updated>2020-04-08T14:25:36.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h1><p>当我们的内容超出了我们的div，往往会出现滚动条，影响美观。</p><p>尤其是当我们在做一些导航菜单的时候。滚动条一出现就破坏了UI效果。我们不希望出现滚动条，也不希望超出去的内容被放逐，就要保留鼠标滚动的效果。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>这里介绍一个简单的方法。大体思路是在div外面再套一个div。这个div设置overflow:hidden。  </p><p>而内容div设置 overflow-y: scroll;overflow-x: hidden;</p><p>然后再设置外层div的width小于内层div的width。</p><p>这个内层div其实是会出现滚动条的，所以不影响鼠标的滚动效果，而且我们看不到滚动条了。</p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>内层div效果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1.png" alt="1.png" title="">                </div>                <div class="image-caption">1.png</div>            </figure><p>套上外层div效果后：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2.png" alt="2.png" title="">                </div>                <div class="image-caption">2.png</div>            </figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>css代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.nav_wrap&#123;</span><br><span class="line">height: 400px;</span><br><span class="line">width: 200px;</span><br><span class="line">overflow: hidden;</span><br><span class="line">border: 1px solid <span class="comment">#ccc;</span></span><br><span class="line">margin: 20px auto;</span><br><span class="line">&#125;</span><br><span class="line">.nav_ul&#123;</span><br><span class="line">height: 100%;</span><br><span class="line">width: 220px;</span><br><span class="line">overflow-y: auto;</span><br><span class="line">overflow-x: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.nav_li&#123;</span><br><span class="line">border: 1px solid <span class="comment">#ccc;</span></span><br><span class="line">margin: -1px;</span><br><span class="line">height: 40px;</span><br><span class="line">line-height: 40px;</span><br><span class="line">text-align: center;</span><br><span class="line">font-size: 12px;</span><br><span class="line">width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.btn_wrap&#123;</span><br><span class="line">text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>html代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class= <span class="string">"nav_wrap"</span>&gt;</span><br><span class="line">&lt;ul class= <span class="string">"nav_ul"</span>&gt;</span><br><span class="line">&lt;li class=<span class="string">"nav_li"</span>&gt;我是菜单1&lt;/li&gt;</span><br><span class="line">&lt;li class=<span class="string">"nav_li"</span>&gt;我是菜单2&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>之前的一个项目中的菜单用到了这个技巧。那个项目用了iframe。 也是让滚动条被遮住了。<br>今天又顺手把目前在做的项目中的导航菜单的滚动条去掉了。 简单总结下来。</p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>演示：<a href="http://runningls.com/demos/2016/css/scroll.html" target="_blank" rel="noopener">http://runningls.com/demos/2016/css/scroll.html</a></p><p>转载于：<a href="https://blog.csdn.net/liusaint1992/article/details/51277751" target="_blank" rel="noopener">https://blog.csdn.net/liusaint1992/article/details/51277751</a><br>作者：liusaint1992</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h1&gt;&lt;p&gt;当我们的内容超出了我们的div，往往会出现滚动条，影响美观。&lt;/p&gt;
&lt;p&gt;尤其是当我们在做一些导航菜单的时候。滚动条一出现就破坏了UI效果
      
    
    </summary>
    
    
      <category term="前端" scheme="https://zhoudyme.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://zhoudyme.github.io/tags/CSS/"/>
    
      <category term="HTML" scheme="https://zhoudyme.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>URL和URI的区别[译][转载]</title>
    <link href="https://zhoudyme.github.io/2018/11/16/3d00c933799e11ea9e7f28d244de8d5a/"/>
    <id>https://zhoudyme.github.io/2018/11/16/3d00c933799e11ea9e7f28d244de8d5a/</id>
    <published>2018-11-16T12:47:10.000Z</published>
    <updated>2020-04-08T14:25:04.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p>译者：华科小涛：<a href="http://www.cnblogs.com/hust-ghtao/" target="_blank" rel="noopener" title="http://www.cnblogs.com/hust-ghtao/">http://www.cnblogs.com/hust-ghtao/</a></p><p>初学http协议，就被这两个相似的术语搞蒙了，查了很多资料，总算搞清楚了。（找资料还是英文啊，靠谱。。。）。</p><p>本篇博客翻译自：<a href="https://danielmiessler.com/study/url_vs_uri/" target="_blank" rel="noopener" title="https://danielmiessler.com/study/url_vs_uri/">https://danielmiessler.com/study/url_vs_uri/</a>，是在是一片简单实用的好文，对帮我们弄清概念很有帮助：</p><p>译文：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/9499986-14aa1143e365bac8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一直存在很多技术上的争论，其中最为妙的恐怕就是web地址应该叫什么的问题。通常情况就是这样：有人把地址栏的内容叫“URL”，这时候有些人就来劲了：“不！其实那时URI。。。”</p><p>对于这种纠正的反应呢，通常也有这么几种情况，心眼小的就寻思这人赶紧走吧，淡定点的就耸耸肩表示同意，火气大的就拔刀相向了好不？</p><p>那这篇文章呢，就对这个只是提供一个简单的总结，毕竟互黑也要黑到点子上是吧。</p><h2 id="URI，URL，URN"><a href="#URI，URL，URN" class="headerlink" title="URI，URL，URN"></a>URI，URL，URN</h2><p>URI = Universal Resource Identifier 统一资源标志符<br>URL = Universal Resource Locator 统一资源定位符<br>URN = Universal Resource Name 统一资源名称</p><p>从上面的那幅图可以看出来，一共有三个不同的概念URI，URL，URN。这讨论这样的问题时，最好的方法就是回到原点啊，这里我们在<a href="http://tools.ietf.org/html/rfc3986" target="_blank" rel="noopener">RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</a>里面收集了点资料：</p><p>“A Uniform Resource Identifier (URI) 是一个紧凑的字符串用来标示抽象或物理资源。”</p><p>“A URI 可以进一步被分为定位符、名字或两者都是. 术语“Uniform Resource Locator” (URL) 是URI的子集, 除了确定一个资源,还提供一种定位该资源的主要访问机制(如其网络“位置”)。“</p><p>那我们无所不知的维基百科把这段消化的很好，并描述的更加形象了：</p><p>“URI可以分为URL,URN或同时具备locators 和names特性的一个东西。URN作用就好像一个人的名字，URL就像一个人的地址。换句话说：URN确定了东西的身份，URL提供了找到它的方式。”</p><p>通过这些描述我们可以得到一些结论：</p><ul><li>首先，URL是URI的一种（通过那个图就看的出来吧）。所以有人跟你说URL不是URI，他就错了呗。但也不是所有的URI都是URL哦，就好像蝴蝶都会飞，但会飞的可不都是蝴蝶啊，你让苍蝇怎么想！</li><li>让URI能成为URL的当然就是那个“访问机制”，“网络位置”。e.g. <code>http://</code> or <code>ftp://</code>.。</li><li>URN是唯一标识的一部分，就是一个特殊的名字。</li></ul><p>　　下面就来看看例子吧，当来也是来自权威的RFC：</p><ul><li><code>ftp://ftp.is.co.za/rfc/rfc1808.txt</code> (also a URL because of the protocol)</li><li><code>http://www.ietf.org/rfc/rfc2396.txt</code> (also a URL because of the protocol)</li><li><code>ldap://[2001:db8::7]/c=GB?objectClass?one</code> (also a URL because of the protocol)</li><li><code>mailto:John.Doe@example.com</code> (also a URL because of the protocol)</li><li><code>news:comp.infosystems.www.servers.unix</code> (also a URL because of the protocol)</li><li><code>tel:+1-816-555-1212</code></li><li><code>telnet://192.0.2.16:80/</code> (also a URL because of the protocol)</li><li><code>urn:oasis:names:specification:docbook:dtd:xml:4.1.2</code></li></ul><p>　　这些全都是URI，其中有些事URL。哪些? 就是那些提供了访问机制的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面到了回答问题的时候了：</p><p>当我们替代web地址的时候，URI和URL那个更准确？</p><p>基于我读的很多的文章，包括RFC，我想说URI更准确。</p><p>别急，我有我的理由：</p><p>我们经常使用的URI不是严格技术意义上的URL。例如：你需要的文件在<code>files.hp.com</code>. 这是URI，但不是URL–系统可能会对很多协议和端口都做出正确的反应。</p><p>你去<code>http://files.hp.com</code> 和<code>[ftp://files.hp.com](ftp://files.hp.com/)</code>.可能得到完全不同的内容。这种情况可能更加普遍，想想不同谷歌域名上的不同服务啊。</p><p>所以，用URI吧，这样你通常技术上是正确的，URL可不一定。最后“URL”这个术语正在被弃用。所以明智吧少年！</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>If you don’t mind being “that guy”, <strong>URI</strong> is probably the more accurate term to use. But if you are in the linguist / “use what’s understood” camp, feel free to go with <strong>URL</strong>.</p><p>参考：</p><p><a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Uniform_Resource_Identifier</a></p><p><a href="https://danielmiessler.com/study/url_vs_uri/" target="_blank" rel="noopener" title="https://danielmiessler.com/study/url_vs_uri/">https://danielmiessler.com/study/url_vs_uri/</a></p><p>转载于：<a href="https://www.cnblogs.com/hust-ghtao/p/4724885.html" target="_blank" rel="noopener">https://www.cnblogs.com/hust-ghtao/p/4724885.html</a><br>作者：华科小涛</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><strong>URL和URN的形式：</strong></p><p><strong>URL</strong></p><p>URI 的最常见形式是统一资源定位符URL，它也被称为 <em>Web 地址</em>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;developer.mozilla.org</span><br><span class="line">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Learn&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;search?q&#x3D;URL</span><br></pre></td></tr></table></figure><p>在浏览器的地址栏中输入上述任一地址，浏览器就会加载相应的网页（资源）。</p><p>URL 由多个必须或可选的组件构成。下面给出了一个复杂的 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.example.com:80&#x2F;path&#x2F;to&#x2F;myfile.html?key1&#x3D;value1&amp;key2&#x3D;value2#SomewhereInTheDocument</span><br></pre></td></tr></table></figure><p><strong>URN</strong></p><p>URN 是另一种形式的 URI，它通过特定命名空间中的唯一名称来标识资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">urn:isbn:9780141036144</span><br><span class="line">urn:ietf:rfc:7230</span><br></pre></td></tr></table></figure><p>上面两个 URN 标识了下面的资源：</p><ul><li>乔治·奥威尔所著的《1984》</li><li>IETF规范7230，超文本传输​​协议 (HTTP/1.1)：Message Syntax and Routing.</li></ul><p><strong>PS：原来URI包括URL和URN，后来URN没流行起来，导致几乎目前所有的URL都是URN(知乎用户)</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;译文&quot;&gt;&lt;a href=&quot;#译文&quot; class=&quot;headerlink&quot; title=&quot;译文&quot;&gt;&lt;/a&gt;译文&lt;/h1&gt;&lt;p&gt;译者：华科小涛：&lt;a href=&quot;http://www.cnblogs.com/hust-ghtao/&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="网络" scheme="https://zhoudyme.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="https://zhoudyme.github.io/tags/HTTP/"/>
    
      <category term="URL" scheme="https://zhoudyme.github.io/tags/URL/"/>
    
      <category term="URI" scheme="https://zhoudyme.github.io/tags/URI/"/>
    
  </entry>
  
  <entry>
    <title>Oracle数据库查询表结构</title>
    <link href="https://zhoudyme.github.io/2018/09/14/ac7be07979a011ea9e7f28d244de8d5a/"/>
    <id>https://zhoudyme.github.io/2018/09/14/ac7be07979a011ea9e7f28d244de8d5a/</id>
    <published>2018-09-14T12:18:09.000Z</published>
    <updated>2020-04-08T14:25:37.869Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  tab_col.table_name AS <span class="string">"表名"</span>, </span><br><span class="line">  tab_cmt.comments AS <span class="string">"表说明"</span>, </span><br><span class="line">  tab_col.column_id AS <span class="string">"字段序号"</span>, </span><br><span class="line">  tab_col.column_name AS <span class="string">"字段名"</span>, </span><br><span class="line">  col_cmt.comments AS <span class="string">"字段说明"</span>, </span><br><span class="line">  tab_col.data_type AS <span class="string">"数据类型"</span>, </span><br><span class="line">  tab_col.data_length AS <span class="string">"数据长度"</span>, </span><br><span class="line">  tab_col.data_precision AS <span class="string">"整数位"</span>, </span><br><span class="line">  tab_col.data_scale AS <span class="string">"小数位"</span> </span><br><span class="line">FROM </span><br><span class="line">  all_col_comments col_cmt, </span><br><span class="line">  all_tab_columns tab_col, </span><br><span class="line">  all_tab_comments tab_cmt </span><br><span class="line">WHERE </span><br><span class="line">  col_cmt.table_name IN (SELECT user_tab.table_name FROM user_all_tables user_tab) </span><br><span class="line">  AND col_cmt.OWNER = tab_col.OWNER </span><br><span class="line">  AND col_cmt.table_name = tab_col.table_name </span><br><span class="line">  AND col_cmt.column_name = tab_col.column_name </span><br><span class="line">  AND tab_cmt.table_name = col_cmt.table_name </span><br><span class="line">  AND tab_cmt.OWNER = col_cmt.OWNER </span><br><span class="line">  AND col_cmt.OWNER = <span class="string">'用户名'</span> </span><br><span class="line">  AND tab_col.table_name = <span class="string">'表名'</span> </span><br><span class="line">ORDER BY </span><br><span class="line">  tab_col.column_id;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://zhoudyme.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Oracle" scheme="https://zhoudyme.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js新手入门指南[转载]</title>
    <link href="https://zhoudyme.github.io/2018/09/07/868ae745799d11ea9e7f28d244de8d5a/"/>
    <id>https://zhoudyme.github.io/2018/09/07/868ae745799d11ea9e7f28d244de8d5a/</id>
    <published>2018-09-07T02:39:24.000Z</published>
    <updated>2020-04-08T14:26:22.234Z</updated>
    
    <content type="html"><![CDATA[<p>最近在逛各大网站，论坛，以及像SegmentFault等编程问答社区，发现Vue.js异常火爆，重复性的提问和内容也很多，楼主自己也趁着这个大前端的热潮，着手学习了一段时间的Vue.js，目前用它正在做自己的结业项目。</p><p>在做的过程中也对Vue.js的官方文档以及其各种特性有了许多认识。作为一个之前以PHP+模版引擎为主的开发，从一个从未接触过除HTML+CSS+JavaScript+JQuery以外的前端技术的人到现在可以独立使用Vue.js以及各种附属的UI库来开发项目，我总结了一些知识和经验想与大家分享。</p><p>下面我就以问答的形式来分享吧。这里假设你仅仅只掌握了HTML+CSS+JavaScript，如果你对JQuery这个前端库，以及各种后端模版语言比如说PHP，JSP还有所了解并且使用过的话那就太好了。</p><h1 id="1-Vue-js是什么？"><a href="#1-Vue-js是什么？" class="headerlink" title="1.Vue.js是什么？"></a>1.Vue.js是什么？</h1><blockquote><p>Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用<a href="https://link.zhihu.com/?target=http%3A//cn.vuejs.org/v2/guide/single-file-components.html">单文件组件</a>和 <a href="https://link.zhihu.com/?target=http%3A//github.com/vuejs/awesome-vue%23libraries--plugins">Vue 生态系统支持的库</a>开发的复杂单页应用。</p><p>Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p><p>如果你是有经验的前端开发者，想知道 Vue.js 与其它库/框架的区别，查看<a href="https://link.zhihu.com/?target=http%3A//cn.vuejs.org/v2/guide/comparison.html">对比其它框架</a>。</p></blockquote><p>这是官网的介绍，是不是觉得非常的抽象非常的官方？看完之后可能还是有很多人不是很懂这个框架到底是用来做什么的，什么是“渐进式框架”？什么是“自底向上增量开发”？什么是“视图层”？什么是“单文件组件”？什么是“复杂的单页应用？”第二段话里面“响应的数据绑定和组合的视图组件”这又是个啥？还有最后一段话，“Vue.js 与其它库/框架的区别”究竟是什么？</p><p>不要担心，如果你慢慢看完这里面的所有问答，一定会对前面那些可能你从未听说过的专业术语有一种恍然大悟的感觉。</p><h1 id="2-Vue-js到底是什么？"><a href="#2-Vue-js到底是什么？" class="headerlink" title="2.Vue.js到底是什么？"></a>2.Vue.js到底是什么？</h1><p>想必现在能看到我这篇文章的人，都是用着APP或者网页版知乎在阅读吧。Vue.js就是一个用于搭建类似于网页版知乎这种表单项繁多，且内容需要根据用户的操作进行修改的网页版应用。</p><h1 id="3-单页应用程序（SPA）"><a href="#3-单页应用程序（SPA）" class="headerlink" title="3.单页应用程序（SPA）"></a>3.单页应用程序（SPA）</h1><p>顾名思义，单页应用一般指的就是一个页面就是应用，当然也可以是一个子应用，比如说知乎的一个页面就可以视为一个子应用。单页应用程序中一般交互处理非常多，而且页面中的内容需要根据用户的操作动态变化。</p><h1 id="4-你前面说的网页版知乎我也可以用JQuery写啊，为什么要用Vue-js呢？"><a href="#4-你前面说的网页版知乎我也可以用JQuery写啊，为什么要用Vue-js呢？" class="headerlink" title="4.你前面说的网页版知乎我也可以用JQuery写啊，为什么要用Vue.js呢？"></a>4.你前面说的网页版知乎我也可以用JQuery写啊，为什么要用Vue.js呢？</h1><p>讲到JQuery，就不得不说到JavaScript的DOM操作了。如果你用JQuery来开发一个知乎，那么你就需要用JQuery中的各种DOM操作方法去操作HTML的DOM结构了。</p><p>现在我们把一个网页应用抽象一下，那么HTML中的DOM其实就是视图，一个网页就是通过DOM的组合与嵌套，形成了最基本的视图结构，再通过CSS的修饰，在基本的视图结构上“化妆”让他们看起来更加美观。最后涉及到交互部分，就需要用到JavaScript来接受用户的交互请求，并且通过事件机制来响应用户的交互操作，并且在事件的处理函数中进行各种数据的修改，比如说修改某个DOM中的innerHTML或者innerText部分。</p><p>我们把HTML中的DOM就可以与其他的部分独立开来划分出一个层次，这个层次就叫做<strong>视图层</strong>。</p><blockquote><p>Vue 的核心库只关注视图层</p></blockquote><p>我们为什么要把视图层抽取出来并且单独去关注它呢？</p><p>因为在像知乎这种页面元素非常多，结构很庞大的网页中，数据和视图如果全部混杂在一起，像传统开发一样全部混合在HTML中，那么要对它们进行处理会十分的费劲，并且如果其中有几个结构之间存在藕断丝连的关系，那么会导致代码上出现更大的问题，这什么问题呢？</p><p>你是否还记得你当初写JQuery的时候，有写过$(‘#xxx’).parent().parent().parent()这种代码呢？当你第一次写的时候，你觉得页面元素不多，不就是找这个元素的爸爸的爸爸的爸爸吗，我大不了在注释里面写清楚这个元素的爸爸的爸爸的爸爸不就好了。但是万一过几天之后你的项目组长或者你的产品经理突然对你做的网页提出修改要求，这个修改要求将会影响页面的结构，也就是DOM的关联与嵌套层次要发生改变，那么$(‘#xxx’).parent().parent().parent()可能就会变成$(‘#xxx’).parent().parent().parent().parent().parent()了。</p><p>这还不算什么，等以后产品迭代越来越快，修改越来越多，而且页面中类似的关联和嵌套DOM元素不止一个，那么修改起来将非常费劲。而且JQuery选择器查找页面元素以及DOM操作本身也是有性能损失的，可能到时候打开这个页面，会变得越来越卡，而你却无从下手。</p><p>当你在编写项目的时候遇到了这种问题，你一定会抱怨，为什么世上会有HTML这种像盗梦空间一样的需要无数div嵌套才能做出页面的语言，为什么当初学JQuery看中的是它简洁的DOM操作，现在却一点也不觉得它有多简洁，难道我学的是假的JQuery？为什么写个代码这么难，你想砸电脑，你想一键盘拍在产品狗的脑袋上，责怪他天天改需求才让你原本花清香茶清味的代码变得如此又臭又长。</p><p>这个时候如果你学过Vue.js，那么这些抱怨将不复存在。</p><h1 id="5-Vue-js为什么能让基于网页的前端应用程序开发起来这么方便？"><a href="#5-Vue-js为什么能让基于网页的前端应用程序开发起来这么方便？" class="headerlink" title="5.Vue.js为什么能让基于网页的前端应用程序开发起来这么方便？"></a>5.Vue.js为什么能让基于网页的前端应用程序开发起来这么方便？</h1><p>因为Vue.js有声明式，响应式的数据绑定，与组件化的开发，并且还使用了Virtual DOM这个看名字就觉得高大上的技术。</p><p>可是这些名词都是啥？</p><h1 id="6-响应式的数据绑定"><a href="#6-响应式的数据绑定" class="headerlink" title="6.响应式的数据绑定"></a>6.响应式的数据绑定</h1><p>这里的响应式不是@media 媒体查询中的响应式布局，而是指vue.js会自动对页面中某些数据的变化做出响应。至于是如何响应的，大家可以先把下面这段代码随便粘贴到一个扩展名为html的文件然后用浏览器打开，随便在文本框里面输入一些文字，观察一下页面变化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;vue.js测试 - 代码之美专栏&lt;/title&gt;</span><br><span class="line">&lt;!-- author:昌维 代码之美 https://zhuanlan.zhihu.com/codes --&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://unpkg.com/vue/dist/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">""</span> value=<span class="string">""</span> placeholder=<span class="string">"在这里输入文字，下面会跟着变化"</span> v-model=<span class="string">"message"</span>&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello Vue!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>是不是会发现一个很神奇的现象，文本框里面输入的文字和后面的p标签中的内容一起变化？</p><p>换句话说，p标签里面通过这个写法与input标签中的value绑定在了一起，其中变化，另外一个和它绑定的数据就跟着变化。</p><p>结合标题来说，就是vue.js会自动响应数据的变化情况，并且根据用户在代码中预先写好的绑定关系，对所有绑定在一起的数据和视图内容都进行修改。而这种绑定关系，在图上是以input 标签的v-model属性来声明的，因此你在别的地方可能也会看到有人粗略的称vue.js为声明式渲染的模版引擎。</p><h1 id="7-组件化开发"><a href="#7-组件化开发" class="headerlink" title="7.组件化开发"></a>7.组件化开发</h1><p>还记得在传统前端开发的时候，我们都是每个人做一个页面，然后最后套入各种后端模版引擎，比如说PHP的Smarty或者Java的JSP等等。</p><p>但是现在我们做单页应用，页面交互和结构十分复杂，一个页面上就有许许多多的模块需要编写，而且往往一个模块的代码量和工作量就非常庞大，如果还按照原先的方法来开发，那么会累死人。而且遇到以后的产品需求变更，修改起来也非常麻烦，生怕动了其中一个div之后，其他div跟着雪崩，整个页面全部乱套，或者由于JavaScript的事件冒泡机制，导致修改一些内层的DOM事件处理函数之后，出现各种莫名其妙的诡异BUG。</p><p>在面向对象编程中，我们可以使用面向对象的思想将各种模块打包成类或者把一个大的业务模块拆分成更多更小的几个类。在面向过程编程中，我们也可以把一些大功能拆分成许多函数，然后分配给不同的人来开发。</p><p>在前端应用，我们是否也可以像编程一样把模块封装呢？这就引入了组件化开发的思想。</p><p>Vue.js通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（component）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。</p><h1 id="8-Virtual-DOM"><a href="#8-Virtual-DOM" class="headerlink" title="8.Virtual DOM"></a>8.Virtual DOM</h1><p>现在的网速越来越快了，很多人家里都是几十甚至上百M的光纤，手机也是4G起步了，按道理一个网页才几百K，而且浏览器本身还会缓存很多资源文件，那么几十M的光纤为什么打开一个之前已经打开过，已经有缓存的页面还是感觉很慢呢？这就是因为浏览器本身处理DOM也是有性能瓶颈的，尤其是在传统开发中，用JQuery或者原生的JavaScript DOM操作函数对DOM进行频繁操作的时候，浏览器要不停的渲染新的DOM树，导致页面看起来非常卡顿。</p><p>而Virtual DOM则是虚拟DOM的英文，简单来说，他就是一种可以预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM。最后在计算完毕才真正将DOM操作提交，将DOM操作变化反映到DOM树上。</p><p>对于vue.js的Virtual DOM，目前业界有着褒贬不一的评价。有人认为Vue.js作为一个轻量级框架，引入Virtual DOM会加大Vue.js本身的代码尺寸，也会消耗更多CPU（手机上会更耗电）（注意：消耗更多的CPU并不意味着会更卡，因为JavaScript计算是后台计算，他的计算量还不至于让DOM操作变得卡顿），并且在操作单个DOM元素的时候，反而多了一道计算工序，会更慢。但也有人认为基本上会用Vue.js开发的都是页面中内容很多的元素，肯定操作的DOM量级普遍较大，平均一下还是比较划算的。</p><h1 id="9-我到底该怎么用Vue-js做单页应用开发？"><a href="#9-我到底该怎么用Vue-js做单页应用开发？" class="headerlink" title="9.我到底该怎么用Vue.js做单页应用开发？"></a>9.我到底该怎么用Vue.js做单页应用开发？</h1><p>说了这么多，我还是不知道怎么用它做出一个像知乎那样的页面啊，到底怎么学它呢？</p><p>前面我们看了一个响应式的数据绑定案例，那只是一个DEMO，而且也看不出有什么实际意义，离真正的单页应用程序还差得远，到底怎么用它开发真实的项目呢？</p><p>我的建议是，先把<a href="https://link.zhihu.com/?target=http%3A//cn.vuejs.org/v2/guide/index.html">介绍 - vue.js</a>官方文档的基础部分硬着头皮看一遍。除了组件这个小节涉及到了很多晦涩难懂的名词以外，前面几章完全就是把Vue.js当作一个模版引擎来用。</p><p>然后开始学习ECMAScript6，Webpack，NPM以及Vue-Cli的基本用法，最好对Node.js也要有所了解。</p><p>最后组件部分先大致看一遍，了解组件里面都有哪些概念之后，开始看网上各种实战视频以及文章还有别人开源的源代码。</p><h1 id="10-在前面你提到过好几次ECMAScript，这是啥？"><a href="#10-在前面你提到过好几次ECMAScript，这是啥？" class="headerlink" title="10.在前面你提到过好几次ECMAScript，这是啥？"></a>10.在前面你提到过好几次ECMAScript，这是啥？</h1><p>ECMAScript听名字好像和JavaScript很像，难不成他们有什么千丝万缕的联系？</p><p>没错你猜对了，他们之间还真有着很深的联系。</p><p>引用阮一峰老师的话：（<a href="https://link.zhihu.com/?target=http%3A//es6.ruanyifeng.com/%23docs/intro">ECMAScript 6入门</a>）</p><blockquote><p>要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是1.0版。</p><p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p><p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。</p></blockquote><p>而ECMAScript6就是新一代的JavaScript语言。</p><p>这里也强烈推荐大家学习ECMAScript6的时候参考这本书<a href="https://link.zhihu.com/?target=http%3A//es6.ruanyifeng.com/">ECMAScript 6入门</a></p><h1 id="11-我在学习Vue-js的时候老是听到Webpack，这是啥？"><a href="#11-我在学习Vue-js的时候老是听到Webpack，这是啥？" class="headerlink" title="11.我在学习Vue.js的时候老是听到Webpack，这是啥？"></a>11.我在学习Vue.js的时候老是听到Webpack，这是啥？</h1><p>Webpack是一个前端打包和构建工具。如果你之前一直是手写HTML，CSS，JavaScript，并且通过link标签将CSS引入你的HTML文件，以及通过Script标签的src属性引入外部的JS脚本，那么你肯定会对这个工具感到陌生。不要紧，我们先来了解一下为什么要用Webpack，然后带着原因去学习就好了。</p><h1 id="12-为什么要用Webpack"><a href="#12-为什么要用Webpack" class="headerlink" title="12.为什么要用Webpack"></a>12.为什么要用Webpack</h1><p>前面说了，做一个单页应用程序本身就相当复杂，而且在做的时候肯定会使用到很多素材和别的第三方库，我们该如何去管理这些东西呢？</p><p>还有前面讲到了Webpack是一个前端打包工具，前端代码为什么要打包呢？因为单页应用程序中用到很多素材，如果每一个素材都通过在HTML中以src属性或者link来引入，那么请求一个页面的时候，可能浏览器就要发起十多次请求，往往请求的这些资源都是一些脚本代码或者很小的图片，这些资源本身才几k，下载连1秒都不需要，但是由于HTTP是应用层协议，它的下层是TCP这个运输层协议，TCP的握手和挥手过程消耗的时间可能比下载资源本身还要长，所以需要把这些小文件全部打包成一个文件，这样只要一次TCP握手和挥手的过程，就把多个资源给下载下来了，并且多个资源由于都是共享一个HTTP请求，所以head等部分也是共享的，相当于形成了规模效应，让网页展现更快，用户体验更好。</p><p>前面说到Webpack还有构建的功能，这就不得不提到了ECMAScript6这个新版本的JavaScript，但是现在国内外还有很多人用着老版本的浏览器，这些浏览器并不支持ECMAScript6，那么我们的前端项目如何在这种浏览器上运行呢？这就需要Webpack的Loader自动载入一个转换器来将我们写的ECMAScript6转换成浏览器能支持的老版本JavaScript语言，这个转换器的名字叫做babel，如果你以后听到或者看到了这个单词，应该要知道它就是一个ECMAScript6 to 老版本JavaScript的转换器了。这也是Webpack的构建功能。当然对前端有更深入的同学还会知道Sass，Less，stylus之类的CSS预处理器，我们也可以通过在Loader中编写特定的规则来实现自动将这些CSS预处理语言转换成普通浏览器能识别的CSS代码。</p><p>开头的介绍提到了vue.js可以使用单文件组件开发项目，其实也是通过Webpack将单文件组件中的模版，样式以及JS转换到主页面中</p><p>当然Webpack不止这点功能，它还可以通过安装各种插件来扩展，比如说热加载技术，就是解放键盘的F5键。让我们修改代码，并且按Ctrl+S保存之后，浏览器页面自动刷新变化，不需要我们去手动刷新，还有一些插件可以自动添加注释，自动给CSS代码加上一些浏览器内核对CSS3兼容前缀，就像webkit-xxx之类的一样。</p><h1 id="13-NPM和Node-js又是什么？它们是什么关系？"><a href="#13-NPM和Node-js又是什么？它们是什么关系？" class="headerlink" title="13.NPM和Node.js又是什么？它们是什么关系？"></a>13.NPM和Node.js又是什么？它们是什么关系？</h1><p>首先讲讲Node.js。我们知道通常情况下，JavaScript的运行环境都是浏览器，因此JavaScript的能力也就局限于浏览器能赋予它的权限了。比如说读写本地系统文件这种操作，一般情况下运行在浏览器中的JavaScript代码是没有这个操作权限的。如果我们想用JavaScript写出一些能够运行在操作系统上的，能够具有像PHP，JAVA之类的编程语言具有的功能的程序该怎么办呢？Node.js就解决了这个问题。Node.js是一个服务端的JavaScript运行环境，通过Node.js可以实现用JavaScript写独立程序。像我们之前提到的Webpack就是Node.js写的，所以作为一个前端开发，即使你不用Node.js写独立程序，也得配一个Node.js运行环境，毕竟很多前端工具都是使用它写的。</p><p>NPM是一个node.js的包管理器。我们在传统开发的时候，JQuery.js大多都是百度搜索，然后去官网下载，或者直接引入CDN资源，这种方法太过于麻烦。如果以后遇到其他的包，这个包的代码本身可能还调用了其他的包（也称这个包和其他的那几个包存在依赖关系），那么我们要在自己的项目中引入一个包将变得十分困难。现在我们有了NPM这个包管理器，直接可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx包名称</span><br></pre></td></tr></table></figure><p>的方式引入它，比如说</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue</span><br></pre></td></tr></table></figure><p>就自动在当前项目文件夹下导入了这个包，并且npm自动下载好了vue这个包依赖的其他包。</p><p>至于有的人在按照网上的npm教程配置的时候踩坑了，发现下载速度很慢或者完全下载不了，那是因为我国有着众所周知的原因，网上也有各种解决方法可以解决这个问题，大家多善用搜索引擎。</p><p>前面提到了Webpack可以安装各种插件来扩展功能，其实也是通过这种方式扩展。</p><p>如果你学过PHP的话，NPM就和PHP里面的Composer差不多。也和CentOS下的yum和Ubuntu下的apt-get差不多。</p><h1 id="14-Vue-CLi又是啥？"><a href="#14-Vue-CLi又是啥？" class="headerlink" title="14.Vue-CLi又是啥？"></a>14.Vue-CLi又是啥？</h1><p>它是一个vue.js的脚手架工具。说白了就是一个自动帮你生成好项目目录，配置好Webpack，以及各种依赖包的工具，它可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure><p>的方式安装，后面的-g表示全局安装的意思，意味着你可以打开命令行之后直接通过vue命令调用它。</p><h1 id="15-我该不该学Vue-js？"><a href="#15-我该不该学Vue-js？" class="headerlink" title="15.我该不该学Vue.js？"></a>15.我该不该学Vue.js？</h1><p>现在Vue.js无论是发展势头还是作者支持还是很好的，而且它本身中文资料就比较多，教程也很多，现在随随便便打开几个和前端开发有关的知乎专栏，基本上都能见到相关文章，社区也很活跃。</p><p>至于你该不该学，取决于你自己，如果你当前只是做做以内容展示为主的项目，或者就是成天用各种CMS建站仿站，并且以后都不打算更换更好的工作，那么可以暂时不用学。如果你开发的项目交互非常多，而且前后端开发都对前后端分离有很清楚的认识，那么可以大胆的学习，并且在实际项目中运用。</p><h1 id="16-Vue-js怎么火起来的？"><a href="#16-Vue-js怎么火起来的？" class="headerlink" title="16.Vue.js怎么火起来的？"></a>16.Vue.js怎么火起来的？</h1><p>关于这个问题，网上说法很多，我自己认为主要还是前些年大前端变革太快，而最近一年开始Vue.js+Webpack这个组合开始逐渐稳定下来了，而且已经有了很多中文资料。</p><p>对比它的竞争对手AngularJS，新旧版本项目无法平滑升级，变革太大让用户感觉不安稳。</p><p>而React本身主流推荐用的是JSX，需要额外学习一门语法（什么？学Vue.js还要学ECMAScript6？现在ECMAScript6是趋势，并不是因为Vue.js才要学的），并且React本身用的是render写法编写模版代码，这让很多用习惯了Smarty等后端模版引擎得人来使用感觉很不适应，现在看来React本身在中国一些论坛社区的火爆程度还是没有Vue.js高。</p><p>当然也并不是说除了Vue.js以外其他框架都很差。像知乎新版也是用React开发的，他还是有各自优秀的地方大家可以深入学习之后做出自己的判断。</p><h1 id="17-我在很多地方还看到Vuex和Vue-route，它们又是什么？"><a href="#17-我在很多地方还看到Vuex和Vue-route，它们又是什么？" class="headerlink" title="17.我在很多地方还看到Vuex和Vue-route，它们又是什么？"></a>17.我在很多地方还看到Vuex和Vue-route，它们又是什么？</h1><p>Vuex是vue的一个状态管理器。用于集中管理一个单页应用程序中的各种状态。</p><p>Vue-route是vue的一个前端路由器，这个路由器不是我们上网用的路由器，而是一个管理请求入口和页面映射关系的东西。它可以实现对页面局部进行无刷新的替换，让用户感觉就像切换到了网页一样。</p><p>要讲清楚这两个东西，又得花费大量篇幅，所以这里只是简单提一下，先学好vue.js本身才是最重要的。</p><h1 id="18-我还在一些地方看到过Vue-resource和Axios，它们又是什么？"><a href="#18-我还在一些地方看到过Vue-resource和Axios，它们又是什么？" class="headerlink" title="18.我还在一些地方看到过Vue-resource和Axios，它们又是什么？"></a>18.我还在一些地方看到过Vue-resource和Axios，它们又是什么？</h1><p>我们在传统的前后端不分离的开发中，后端直接把数据通过模版引擎拼接进了返回的HTML中。而现在做单页应用程序属于前后端分离开发，那么这个单页应用程序中的数据就得通过ajax的方式获取，也要通过ajax的方式提交到后端。</p><p>在传统开发中我们都是通过xmlhttprequest手动操作，或者通过JQuery的ajax方法来进行数据提交获取。</p><p>vue.js本身没有封装ajax操作库，所以我们要通过Vue-resource和Axios来进行ajax操作，而因为种种原因，现在vue.js2.0已经将axios作为官方推荐的ajax库了。</p><h1 id="19-我该学Vue-js2-0还是1-0呢？"><a href="#19-我该学Vue-js2-0还是1-0呢？" class="headerlink" title="19.我该学Vue.js2.0还是1.0呢？"></a>19.我该学Vue.js2.0还是1.0呢？</h1><p>现在很多框架和语言都是学新不学旧（Python慢慢也变得如此），因此如果不是为了维护老旧项目，肯定推荐学Vue.js2.0。而且学会了Vue.js2.0，再去学习Vue.js1.0也不是什么难事。</p><h1 id="20-写Vue-js用什么开发工具和电脑呢？"><a href="#20-写Vue-js用什么开发工具和电脑呢？" class="headerlink" title="20.写Vue.js用什么开发工具和电脑呢？"></a>20.写Vue.js用什么开发工具和电脑呢？</h1><p>前端开发基本上不需要太高端的电脑都能胜任，现在这个时代是台电脑，装个编辑器都可以做前端开发的。</p><p>Vue.js的组件文件本质上还是普通的代码文件，所以各种编辑器配合一些语法检查插件就足够了。我自己用的是sublime text 3，安装一些插件之后可以实现.vue单文件组件高亮代码以及各种自动完成。Webstorm中也有类似插件，大家可以在网上各种教学文章的指导下配置好环境。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>可能包括我在内的很多人在看到Vue.js那神奇的双向绑定优雅写法都会有一种非常惊艳，而看到中文文档发布之后有种想立马学习的冲动。可惜大前端终究是大前端，如果一个对于前端各个方面没有深入认识就想着能一步登天，肯定对不起大前端的“大”字。原本看着只想学一个Vue.js，没想到顺带把ECMAScript6，Webpack配置，ESLint配置，bable配置，npm使用，node.js语法，以后vue全家桶中的vuex，vue-route等等等等都学了一遍。前段时间网上也流传出了一个职位叫做Webpack配置工程师，从这里也可以看出弄懂前端这个大杂烩确实不是那么容易。大家一起加油，有什么问题也可以在评论区回复，我会抽空补充在文章内容中。谢谢各位的支持！~</p><p>转载于：<a href="https://zhuanlan.zhihu.com/p/25659025" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25659025</a><br>作者：昌维</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在逛各大网站，论坛，以及像SegmentFault等编程问答社区，发现Vue.js异常火爆，重复性的提问和内容也很多，楼主自己也趁着这个大前端的热潮，着手学习了一段时间的Vue.js，目前用它正在做自己的结业项目。&lt;/p&gt;
&lt;p&gt;在做的过程中也对Vue.js的官方文档以
      
    
    </summary>
    
    
      <category term="前端" scheme="https://zhoudyme.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://zhoudyme.github.io/tags/JavaScript/"/>
    
      <category term="Vue" scheme="https://zhoudyme.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>记一次Win10安装MySQL Server 5.7.20失败</title>
    <link href="https://zhoudyme.github.io/2018/08/31/b2aa18f2781211ea944c28d244de8d5a/"/>
    <id>https://zhoudyme.github.io/2018/08/31/b2aa18f2781211ea944c28d244de8d5a/</id>
    <published>2018-08-31T13:18:45.000Z</published>
    <updated>2020-04-08T14:25:30.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题状况"><a href="#问题状况" class="headerlink" title="问题状况"></a>问题状况</h1><p>在Win10下使用mysql-installer-community-5.7.20.0的msi包进行安装，试了好多次，MySQL Server 5.7.20的安装状态都显示为Failed，安装失败。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1.png" alt="1.png" title="">                </div>                <div class="image-caption">1.png</div>            </figure><p>MySQL installer详细日志如下：</p><pre><code>1: Action 20:16:10: INSTALL.1: 1: MySQL Server 5.7 2: {81B27388-3733-4B65-8D84-AD9C9113B498}1: Action 20:16:10: FindRelatedProducts. Searching for related applications1: Action 20:16:10: AppSearch. Searching for installed applications1: Action 20:16:11: LaunchConditions. Evaluating launch conditions1: This application requires Visual Studio 2013 Redistributable. Please install the Redistributable then run this installer again.1: 1: MySQL Server 5.7 2: {81B27388-3733-4B65-8D84-AD9C9113B498} 3: 31: The action &apos;Install&apos; for product &apos;MySQL Server 5.7.20&apos; failed.</code></pre><p>仔细查看日志，发现”This application requires Visual Studio 2013 Redistributable. Please install the Redistributable then run this installer again.”，在安装过程中确实提示需要安装Microsoft Visual c++ 2013 Redistributable。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2.png" alt="2.png" title="">                </div>                <div class="image-caption">2.png</div>            </figure><p>可是我已经按照提示安装了，在系统的程序和功能里面也能看到”Microsoft Visual c++ 2013 Redistributable(X64) - 12.0.30501”的安装信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="3.png" alt="3.png" title="">                </div>                <div class="image-caption">3.png</div>            </figure><p>但是日志里面还是提示需要安装Visual Studio 2013 Redistributable。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>试着搜索了一下，按照网上的提示升级安装了12.0.40660版本的Microsoft Visual c++ 2013 Redistributable，再安装MySQL Server 5.7.20，果然问题就解决了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="4.png" alt="4.png" title="">                </div>                <div class="image-caption">4.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="5.png" alt="5.png" title="">                </div>                <div class="image-caption">5.png</div>            </figure><p>暂时不知道是什么原因，可能是mysql-community-5.7.20.0版的bug吧。<br>附上Microsoft Visual C++ 2013 Redistributable Package 12.0.40660的下载链接：<br>来源: <a href="https://support.microsoft.com/en-us/kb/3179560" target="_blank" rel="noopener">Microsoft Support</a></p><p>x86：<a href="http://download.microsoft.com/download/1/8/0/180FA2CE-506D-4032-AAD1-9D7636F85179/vcredist_x86.exe" target="_blank" rel="noopener">点击下载</a></p><p>x64：<a href="http://download.microsoft.com/download/1/8/0/180FA2CE-506D-4032-AAD1-9D7636F85179/vcredist_x64.exe" target="_blank" rel="noopener">点击下载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题状况&quot;&gt;&lt;a href=&quot;#问题状况&quot; class=&quot;headerlink&quot; title=&quot;问题状况&quot;&gt;&lt;/a&gt;问题状况&lt;/h1&gt;&lt;p&gt;在Win10下使用mysql-installer-community-5.7.20.0的msi包进行安装，试了好多次，MyS
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://zhoudyme.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://zhoudyme.github.io/tags/MySQL/"/>
    
      <category term="Windows" scheme="https://zhoudyme.github.io/tags/Windows/"/>
    
  </entry>
  
</feed>
